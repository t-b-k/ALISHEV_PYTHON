# Множества (мешок)

# Множество - НЕупорядоченный набор УНИКАЛЬНЫХ объектов (возможно разных типов)
# set() или {}

# Когда рекомендуется использовать множество вместо списка? 
# 1. Когда мы хотим хранить только уникальные элементы
# 2. Когда нас не интересует порядок добавления
# 3. Когда нам нужно иметь возможность быстро определять вхождение некоторого элемента в нашу совокупность объектов
# (при помощи оператора in)
# В случае, если мы применяем оператор in к множеству, ответ нам дается мгновенно, так как для этого используется 
# специальная структура - хэш-таблица. Если оператор in применяется к списку, происходит линейный поиск - 
# просмотр всех элементов списка один за другим, пока не наткнемся на интересующий нас элемент. 

set1 = {}
print(set1)

set1 = {1, 10, 5, 2, 10, "hello!"} # <==> set1 = set([1, 10, 5, 2, 10, "hello!"])
print(set1)
print(type(set1))

# !!! Пустое множество нельзя создать при помощи фигурных скобок. Это будет словарь - <class 'dict'> !!!
set2 = {}
print(type(set2))

# ДОБАВЛЕНИЕ ЭЛЕМЕНТА В МНОЖЕСТВО. Оператор add
set1.add(13)
set1.add("Мама")
print(set1)

for i in set1 : 
    print(i)

# Задача: убрать из списка все дубликаты
my_list = [1, 2, 1, 1, 5, "hello", "hello"]
my_set = set(my_list)
print(my_set)
my_new_list = list(my_set)
print(my_new_list)

print(5 in my_set)
print(15 not in my_set)

# Задача: найти сумму уникальных элементов в списке
lst = [1, 1, 2, 5, 10, 10, 10]
sum_of_uniques = 0
for elem in set(lst) : 
    sum_of_uniques += elem
print(sum_of_uniques)

# То же самое гораздо проще можно реализовать с помощью встроенной функции sum, 
# работающей на коллекциях: 

print(sum(set(lst)))

# Задача: 
# Написать функцию с двумя аргументами - my_set и my-list, возвращающую True, если 
# все элементы списка содержатся во множестве, и False в противном случае. 

my_set = {1, 2, 3, 4, 5, 6, 7, 8}
my_list = [1, 1, 3, 7, 2, 8]

def if_all_contained (st, lst) : 
    return len({elem in my_set for elem in my_list}) == 1

print(if_all_contained(my_set, my_list))
